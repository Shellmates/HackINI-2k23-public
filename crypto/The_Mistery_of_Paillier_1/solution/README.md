# The Mistery of Paillier 1

## description

> See if you can get some secrets out of this [Encrypted](enc)}.

## Write-Up

From the title of the challenge, we find that the challenge uses **Paillier Encryption** :

> The Paillier cryptosystem, invented by and named after Pascal Paillier in 1999, is a probabilistic asymmetric algorithm for public key cryptography. The problem of 
> computing n-th residue classes is believed to be computationally difficult. The decisional composite residuosity assumption is the intractability hypothesis upon 
> which this cryptosystem is based. 

And since we have all assets and key needed for the decryption, let's execute the algorithm that do the decryption

```py
#import math
import random
from random import shuffle
import sys
import gmpy2
from time import time
from Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long


# In[2]:


def gcd(a,b):
    while b > 0:
        a, b = b, a % b
    return a
    
def lcm(a, b):
    return a * b // gcd(a, b)    
    
    
def int_time():
    return int(round(time() * 1000))

class PrivateKey(object):
    def __init__(self, p, q, n):
        #self.l = lcm(p-1,q-1)----This is added as requested by the setup BUT not used, shortcut is used!
        self.l = (p-1) * (q-1)
        #self.m = gmpy2.invert(gmpy2.f_div(gmpy2.sub(gmpy2.powmod(n+1,self.l,n*n),gmpy2.mpz(1)),pub.n),n) --- Shortcut used instead of it
        self.m = gmpy2.invert(self.l, n)  #1/fi(n)
    def __repr__(self):
        return '<PrivateKey: %s %s>' % (self.l, self.m)

class PublicKey(object):

    @classmethod
    def from_n(cls, n):
        return cls(n)
    def __init__(self, n):
        self.n = n
        self.n_sq = n * n
        self.g = n + 1
    def __repr__(self):
        return '<PublicKey: %s>' % self.n
    
def generate_keypair(bits):
    p_equal_q = True
    while p_equal_q:
        p = getPrime(bits // 2)
        q = getPrime(bits // 2)
        if (p!=q):
            p_equal_q = False
    n = p * q
    return PrivateKey(p, q, n), PublicKey(n)

def encrypt(pub, plain):
    one = gmpy2.mpz(1)
    state = gmpy2.random_state(int_time())
    r = gmpy2.mpz_random(state,pub.n)
    while gmpy2.gcd(r,pub.n) != one:
        state = gmpy2.random_state(int_time())
        r = gmpy2.mpz_random(state,pub.n)
    x = gmpy2.powmod(r,pub.n,pub.n_sq)
    cipher = gmpy2.f_mod(gmpy2.mul(gmpy2.powmod(pub.g,plain,pub.n_sq),x),pub.n_sq)
    return cipher

def decrypt(priv, pub, cipher):
    one = gmpy2.mpz(1)
    x = gmpy2.sub(gmpy2.powmod(cipher,priv.l,pub.n_sq),one)
    plain = gmpy2.f_mod(gmpy2.mul(gmpy2.f_div(x,pub.n),priv.m),pub.n)
    if plain >= gmpy2.f_div(pub.n,2):
        plain = plain - pub.n
    return plain

class PrivateKeyGen(object):
    def __init__(self, l, m):
        self.l = l
        self.m = m
    def __repr__(self):
        return '<PrivateKey: %s %s>' % (self.l, self.m)

class PublicKeyGen(object):
    def __init__(self, n):
        self.n = n
        self.n_sq = n * n
        self.g = n + 1
    def __repr__(self):
        return '<PublicKey: %s>' % self.n

if __name__ == '__main__':
    n = 28969443953166212176900669471436119085757229026148586965849188345197940217327767120707632941606505649477012294014418580248714089093252684831166301156632827176925795023676464336839175425853628428955514439247726777634593937732531120413086199685700686206997034465415894575407874200829366958859453077260773947703940164206926106401228608805610208364949404694734707999603964890187705114702866607291169518975624151299550469486765232382773505993666858156307598173347828398015248426051954947105370370595066369274603824773950241630148142718542824034714695997521337673688478054578127978308776091723551403034458711208929672784579
    l = 28969443953166212176900669471436119085757229026148586965849188345197940217327767120707632941606505649477012294014418580248714089093252684831166301156632827176925795023676464336839175425853628428955514439247726777634593937732531120413086199685700686206997034465415894575407874200829366958859453077260773947703599735477406064524238720430822343325920684833389664573667279160501188282274739244265693925088943408682129985780703069811129030911706887239998653652140412154766477913849452000024620184892247236935773328343691706484331881658128315273303889765486558002682573220199544173166370622070041065546759527822847546481920
    m = 1080688360336896456921907889962548947850786121329604158041831438369555233499568965771308516607429728117328527476582986601829655002388575612859107724107529826540595263615851475490512287703731533137795123693942848480702844415291149123218168776861310131973231803336195972756359121185701863826146689458358005704560209519767094006896271408456804532722847578383017873651341355831055059184976211129976747968708863370847626458502230870841129611645580707474126440233276072491932249465722278793532160034854357644929368878424960356896439064892153793545908369705243273966193834753403909443138667265310016760579731152769268775798
    cipher = 638546834487629834151420149128874339591029835699044779403116902411742502681170373809477437551846699682448938226735851131033031447151452333964990410715105159686615821728654727042530722990565442782868991875719167086227796054974309051282136857058067769255878702361577464331340463340591386880956821946916211318631702392825155877660535955981204158581642743865377795807940970063486812618687066635925524837868423232910037110009551403868859022010916977393742307666877545885638985858733685873218883810477894819332201219456941057733608515136358716952588988960733670960595152405629685970190325964101598428576876998753853274500749846161349634110978340584421653155494427607231988181375108752243603562343716286715736677866282592232144623441453395059690106490857039108143211962028669329636495547609814551820352197372819200257035594034683999676224542258816963750545335777542119604986644221367687901586263397239554177123101417753272849953207692932179628503499807069446873762215774643623147062526044855371192122311251771703718636916897906668137122601028299153317115950929248860291368879402305831478388641449295980181258131657856275283899360889153776981669107883060044120321019118183317028900303340108210619656578783248753236333044268238598578093881738

    privateKey = PrivateKeyGen(l, m)
    publicKey = PublicKeyGen(n)

    text = "shellmates{unl0ck_th3_Mys73ry_0f_p41113r_5d8f6b}"
    plain = bytes_to_long(text.encode())

    decrypted = decrypt(privateKey, publicKey, cipher)
    flag = long_to_bytes(decrypted).decode()
    print("Flag : " + flag)
```

## Flag

shellmates{unl0ck_th3_Mys73ry_0f_p41113r_5d8f6b}

## More information

 - Encryption and Decryption Code : https://erev0s.com/blog/paillier-cryptosystem-python/